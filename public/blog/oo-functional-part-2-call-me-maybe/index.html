<html><head><link href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.1.0/css/bulma.min.css" rel="stylesheet"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/monokai-sublime.min.css"/><link href="http://fonts.googleapis.com/css?family=Playfair+Display|Amiri" rel="stylesheet" type="text/css"/><link href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css" rel="stylesheet"/><link rel="stylesheet" href="/app.css"/><title>OO + Functional - Part 2 - Call Me Maybe? | Journey Through Cyberspace &amp; Realtime</title><meta property="og:title" content="OO + Functional - Part 2 - Call Me Maybe?"/><meta property="og:type" content="article"/><meta property="og:url" content="https://i.am.benjaminclos.com/blog/oo-functional-part-2-call-me-maybe"/><meta property="og:author" content="Benjamin Clos"/><meta property="og:description" content="The second part in a series of thoughts on the benefits of marrying Functional and OOP principles, focusing on extending the Monad as a Maybe."/><meta property="og:published_time" content="2016-08-17T04:00:00.000Z"/><meta property="og:tags" content="[object Object], [object Object], [object Object], [object Object]"/></head><body class="blog"><div class="_app_kqw8u_3804 "><div class="_top_kqw8u_3838 _navigation_kqw8u_3838 _detached_kqw8u_3855 "><div class="_container_kqw8u_242 "><div class="_nav_kqw8u_1722 "><div class="_nav-center_kqw8u_2997 "><a class="_nav-item_kqw8u_2925 " href="/">home</a><a class="_nav-item_kqw8u_2925 " href="/blog">blog</a><a class="_nav-item_kqw8u_2925 " href="/blog/tags">tags</a></div></div></div></div><div class="_main_kqw8u_3810 "><div class="_container_kqw8u_242 "> <div class="_columns_kqw8u_1930 "><div class="_column_kqw8u_1925 _is-8_kqw8u_1995 _is-offset-2_kqw8u_1968 "><article class="_container_kqw8u_242 "><header><h1 class="_title_1hssj_21 ">OO + Functional - Part 2 - Call Me Maybe?</h1><h3>8.17.2016</h3><h3>Benjamin Clos</h3><h3 class="_tag-list_1hssj_14 "><a href="/blog/tags/javascript">javascript</a><a href="/blog/tags/functional">functional</a><a href="/blog/tags/oop">oop</a><a href="/blog/tags/series-monads">series:monads</a></h3></header><div class="_content_1hssj_37 _block_kqw8u_238 "><p><em>This is the second post in a series of posts on the benefits of merging Functional Javascript with Object-Oriented Javascript.  The <code>Monad</code> class we are referencing here we previously defined in <a href="/blog/better-together-part-1-monad/">the first post</a>.</em></p>
<h2>Call Me Maybe?</h2>
<p>With our base <code>Monad</code> in tow, let's create a useful <code>Maybe</code> monad that allows us to safely short circuit when we find a <code>Nothing</code> in our computational chains.</p>
<p><code>Nothing</code> in the context of Javascript is <code>null</code> or <code>undefined</code>, a constant pain where most language generally only have a singular Constant to represent <code>Nothing</code></p>
<p>Let's take a classic example of a nonuniform state transition where we may run into a problem with a <code>Nothing</code> in Javascript.</p>
<pre><code class="hljs">
Users.find(fakeId).then( user =&gt; {
  user.name <span class="hljs-comment">// throws</span>
})

Users.find(realId).then( user =&gt; {
  user.name <span class="hljs-comment">// is fine!</span>
})

</code></pre>
<p><img src="http://imgs.xkcd.com/comics/schrodinger.jpg" alt="lol javascript"></p>
<p>We don't actually know if user is <code>Nothing</code> until we look, and this can cause all sorts of problems for Javascript developers, experienced and beginners alike.  The wise among you will note that you can use <code>Promise.prototype.catch</code> to handle such an error, but the added noise that this can incur in your <code>catch</code> handler generally distracts from the clarity of handling actual operational errors, like recovering from a network partition, an unreachable database, or a filesystem error via properly scoped <a href="http://bluebirdjs.com/docs/api/catch.html#filtered-catch"><code>Error</code></a> objects.</p>
<p>It would be more meaningful to simply short-circuit this type of operation most of the time.</p>
<h2>Call Me Maybe?</h2>
<p>Let's extend our base <code>Maybe</code> to create our <code>Maybe</code> monad to help with this problem.</p>
<pre><code class="hljs">
<span class="hljs-keyword">const</span>
  Monad = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./Monad"</span>)

<span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maybe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Monad</span> </span>{
  <span class="hljs-comment">// creating an explicit static property</span>
  <span class="hljs-comment">// allows Maybe to play nicely with dot notation creation</span>
  <span class="hljs-keyword">static</span> Maybe (val) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Maybe(val)
  }
  <span class="hljs-comment">// as long as this is empty it's a NOOP</span>
  fmap (fn) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor( <span class="hljs-keyword">this</span>.isNothing ? <span class="hljs-keyword">this</span> : fn(<span class="hljs-keyword">this</span>()) )
  }

  <span class="hljs-comment">// don't tell the Functionalist zealots I did this</span>
  <span class="hljs-comment">// in Javascript this makes our life a lot easier</span>
  get isNothing () {
    <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>()
    <span class="hljs-keyword">return</span> self === <span class="hljs-literal">undefined</span> || self === <span class="hljs-literal">null</span>
  }
}

</code></pre>
<p>Since this extends the <code>Monad</code> and thus the <code>Function</code> we can transparently do some useful state transitions (<code>fmap</code>) with it. How about we give it a whirl to highlight the utility of our new <code>Maybe</code> vs our base <code>Monad</code>.</p>
<pre><code class="hljs">
<span class="hljs-keyword">const</span> creditsInEuros = user =&gt; user.credit * <span class="hljs-number">1.34</span> <span class="hljs-comment">// arbitrary conversion rate</span>

<span class="hljs-keyword">const</span> zilch = Monad.of(<span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> user  = Maybe.of(<span class="hljs-literal">undefined</span>)

<span class="hljs-built_in">console</span>.log(creditsInEuros(<span class="hljs-literal">undefined</span>))  <span class="hljs-comment">// Throws</span>
<span class="hljs-built_in">console</span>.log(zilch(creditsInEuros))      <span class="hljs-comment">// Throws as well</span>
<span class="hljs-built_in">console</span>.log(user(creditsInEuros))       <span class="hljs-comment">// Maybe&lt;undefined&gt; : No Error!</span>

</code></pre>
<p>This seemingly arbitary difference is incredibly important, because we now can decoupling our state transitions from our logical branches. This reduces our cognitive overhead, and adds a level of reliability and reuse to our logical branches (the <code>Maybe</code> in this case).</p>
<p>This is the same idea, written in a more traditional <code>if/else</code> approach</p>
<pre><code class="hljs">
<span class="hljs-comment">// if we were to rewrite our creditsInEuros in a more</span>
<span class="hljs-comment">// traditional short-circuit</span>
<span class="hljs-keyword">const</span> creditsInEuros = user =&gt; {
  <span class="hljs-comment">// what if we later want to perform a similar `fmap`</span>
  <span class="hljs-comment">// on a user.cart where we want to the sum?</span>
  <span class="hljs-comment">// we have to copy this logic there.</span>
  <span class="hljs-keyword">return</span> user &amp;&amp; user.credit &amp;&amp; user.credit * <span class="hljs-number">1.34</span>
}

</code></pre>
<p>This is admittedly a simplistic scenario, but let's try something a bit more involved, like User lookups and refactoring it to take advantage of our newly minted <code>Maybe</code> monad and the inherited ability for our base <code>Monad</code> to be absorbed by a <code>Promise</code>.</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> 
    <span class="hljs-built_in">Promise</span>         = <span class="hljs-built_in">require</span>(<span class="hljs-string">"bluebird"</span>)
  , nonExistantUser = <span class="hljs-literal">null</span>
   <span class="hljs-comment">// destructure it so we utilize our pure creation interface</span>
  , {Maybe}         = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./Maybe"</span>)
  , Fred            = { name : <span class="hljs-string">"Fred"</span> }

<span class="hljs-comment">// We are going to use Promise.resolve to generalize some asynchronous lookup</span>
<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-literal">null</span>).then(Maybe).then( nonExistantUser =&gt; {
  <span class="hljs-keyword">throw</span> <span class="hljs-string">"I should have never ran"</span>
}).catch(<span class="hljs-built_in">console</span>.log)

<span class="hljs-built_in">Promise</span>.resolve(fred).then(Maybe).then(<span class="hljs-built_in">console</span>.log)
<span class="hljs-comment">/*
output :
{ name: 'fred' }
doesn't throw because our Maybe absorbed the null state 
*/</span>

</code></pre>
<p>Well look at that; we just gracefully short-circuited a null lookup in our Promise chain.  Please note we are using the more explicit <code>Maybe</code> creation via <code>Maybe.Maybe</code> in our example by destructuring the <code>Maybe</code> class with <code>{Maybe}</code>.  This could also be accomplished using <a href="http://bluebirdjs.com/docs/api/promise.bind.html"><code>Promise.prototype.bind</code></a> method and <code>Maybe.of</code>.</p>
<p>Take a stab at rewriting it using <code>bind</code> and <code>Maybe.of</code> in the comments below!</p>
<p>Another important logical branch is the ability to recover from a <code>Nothing</code>.
In my next post, I will discuss how you can create and use the <code>Either</code> monad to gracefully recover with a default value with <code>Nothing</code>.</p>
</div></article><section class="section comments"><div class="content"><div id="disqus_thread"><script>(function() {  // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//benjaminclos.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></div></div></section></div></div></div></div><div class="_navigation_kqw8u_3838 _bottom_kqw8u_3901 "><div class="_container_kqw8u_242 "><div class="_nav_kqw8u_1722 "><div class="_nav-center_kqw8u_2997 "><a class="_nav-item_kqw8u_2925 " href="https://github.com/ondreian"><i class="ion-social-github"></i></a><a class="_nav-item_kqw8u_2925 " href="https://twitter.com/benjaminclos"><i class="ion-social-twitter"></i></a></div></div></div></div></div><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-82549801-1', 'auto');
ga('send', 'pageview');</script></body></html>